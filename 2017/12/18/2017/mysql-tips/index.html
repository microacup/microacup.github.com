<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#202020"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="keywords" content="MySQL,性能,SQL,"><meta name="description" content="MySQL性能优化技巧"><link rel="icon" type="image/x-icon" href="/logo.png"><title>MySQL性能优化技巧 [ 大新闻 ]</title><link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" href="/css/microb.css"></head><body><nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed"><ul class="pure-menu-list float-r clearfix"><li class="pure-menu-item toc-menu"><a id="menu-main-post" class="pure-menu-link" href="javascript:;"><img class="menu-icon" src="/logo.png" alt="MENU"></a></li></ul><a class="pure-menu-heading" href="/"><h1 class="title">大新闻</h1></a></nav><div class="container" id="content-outer"><div class="inner" id="content-inner"><article class="post" id="post"><header class="post-header text-center"><h1 class="title">MySQL性能优化技巧</h1><time class="time" datetime="2017-12-18T09:41:32.000Z">2017-12-18</time><hr></header><div class="post-content"><blockquote><p>本文是关于 MySQL 中索引、查询优化等的 Tips。</p></blockquote><a id="more"></a><h2 id="1-索引篇"><a href="#1-索引篇" class="headerlink" title="1. 索引篇"></a>1. 索引篇</h2><p>MySQL 的索引是一颗以 B+树为主的数据结构，叶子节点增加了下个节点的指针。</p><ul><li>MyISAM 索引，叶子节点存放的是数据记录的地址，非聚集索引。</li></ul><ul><li>InnoDB 索引，叶子节点本身就是数据文件，是聚集索引。<ul><li>数据文件本身就是主键索引，所以必须要有主键。尽量使用一个自增字段作为主键。</li><li>辅助索引叶子存储的是主键，辅助索引搜索需要检索两遍索引，先找主键，再找记录。</li></ul></li><li>更多：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li></ul><p><strong>MySQL 使用索引的情况</strong>：</p><ul><li>where 子句</li><li>MIN, MAX 函数</li><li>ORDER BY, GROUP BY 子句</li></ul><h3 id="1-0-建立索引的原则"><a href="#1-0-建立索引的原则" class="headerlink" title="1.0 建立索引的原则"></a>1.0 建立索引的原则</h3><ul><li><p>最左匹配（联合索引），mysql 会从左至右匹配，直到遇到范围（&gt;,&lt;,between,like)停止，例如 a = 1 and b = 2 and <strong>c &gt; 3</strong> and d = 4 如果建立(a,b,c,d)顺序的索引，d 是用不到索引的</p></li><li><p>=和 in 的写作顺序可以乱序，mysql 会执行优化</p></li><li><p>在区分度高的列建立索引，Selectivity = count(distinct col)/count(*) ，Selectivity 越接近 1 越好。例如性别列不适合建立索引。</p></li><li><p>注意字符索引的长度，结合区分度，选择合适的字段长度建立索引</p></li><li><p>索引列不要参与计算，不能使用函数和表达式</p></li><li><p>在现有基础上扩展索引，避免新增索引</p></li><li><p>InnoDB 上永远使用自增长的字段作为主键，物理存储按照顺序存放，减少了磁盘开销</p></li></ul><h3 id="1-1-负向条件查询不能使用索引"><a href="#1-1-负向条件查询不能使用索引" class="headerlink" title="1.1 负向条件查询不能使用索引"></a>1.1 负向条件查询不能使用索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">and</span> <span class="keyword">status</span> != <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>id</code> 和<code>status</code>将无法使用索引。同样<code>not exists</code>等都不可以。</p><p>尽可能将这些查询改为正向条件，如<code>id in (3, 4)</code></p><h3 id="1-2-联合索引与最左前缀"><a href="#1-2-联合索引与最左前缀" class="headerlink" title="1.2 联合索引与最左前缀"></a>1.2 联合索引与最左前缀</h3><p>有联合索引&lt; a, b, c &gt;，进行精确匹配时（in 或=），索引按照最左前缀原则。组合索引区分度最高的在左边。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 能用到全部索引的常规写法</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> a = <span class="string">''</span> <span class="keyword">and</span> b= <span class="string">''</span> <span class="keyword">and</span> c <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"># 也能用到全部索引的常规写法，mysql对查询条件自动优化，与in和=后的写作顺序无关</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> b= <span class="string">''</span> <span class="keyword">and</span> a = <span class="string">''</span> <span class="keyword">and</span> c <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"># 只能用到a</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> a = <span class="string">''</span> <span class="keyword">and</span> c <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"># 无法使用索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> c <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"># 范围列只会用到一个索引，范围后的列无法使用索引，只能用到a</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> a &gt; <span class="number">100</span> <span class="keyword">and</span> b &lt; <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-查询条件中的函数或表达式不能使用索引"><a href="#1-3-查询条件中的函数或表达式不能使用索引" class="headerlink" title="1.3 查询条件中的函数或表达式不能使用索引"></a>1.3 查询条件中的函数或表达式不能使用索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> <span class="keyword">YEAR</span>(<span class="built_in">date</span>) &lt; = <span class="string">'2017'</span></span><br></pre></td></tr></table></figure><blockquote><p>如果索引有此列， 也可能是索引全扫描。</p><p><code>SELECT * from</code>table<code>where (b+1)&gt;2 and left(c,2) =&#39;a111&#39;</code></p></blockquote><h3 id="1-4-前导模糊不能使用索引"><a href="#1-4-前导模糊不能使用索引" class="headerlink" title="1.4 前导模糊不能使用索引"></a>1.4 前导模糊不能使用索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> <span class="keyword">desc</span> <span class="keyword">like</span> <span class="string">'%XX'</span></span><br></pre></td></tr></table></figure><p>请使用搜索引擎代替。</p><h3 id="1-5-使用-limit"><a href="#1-5-使用-limit" class="headerlink" title="1.5 使用 limit"></a>1.5 使用 limit</h3><p>如果明确知道只有一条结果返回，limit 1 能够提高效率</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> login_name=? <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动</p><h3 id="1-6-少量的数据不应该索引"><a href="#1-6-少量的数据不应该索引" class="headerlink" title="1.6 少量的数据不应该索引"></a>1.6 少量的数据不应该索引</h3><p>小于 k 级别的数据，索引提供的效率提升并不明显，反而增加了维护索引的代价。</p><h2 id="2-优化查询"><a href="#2-优化查询" class="headerlink" title="2. 优化查询"></a>2. 优化查询</h2><h3 id="2-1-慢查询"><a href="#2-1-慢查询" class="headerlink" title="2.1 慢查询"></a>2.1 慢查询</h3><ol><li>打开慢查询日志</li><li>确定 where 后哪个字段查询记录最少，区分度最高</li><li>explain 查看执行计划</li><li>order by limit 让排序的表优先查</li><li>根据业务场景，优化索引</li></ol><h3 id="2-2-避免使用自动类型转换"><a href="#2-2-避免使用自动类型转换" class="headerlink" title="2.2 避免使用自动类型转换"></a>2.2 避免使用自动类型转换</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> <span class="keyword">col</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> <span class="keyword">col</span> = <span class="string">'4'</span>;</span><br></pre></td></tr></table></figure><p>以上两条都能执行成功，但是请确定真正的类型与列一致。</p><blockquote><p>类型转换可能导致索引失效。</p></blockquote><h3 id="2-3-尽量把数据列设为-NOT-NULL"><a href="#2-3-尽量把数据列设为-NOT-NULL" class="headerlink" title="2.3 尽量把数据列设为 NOT NULL"></a>2.3 尽量把数据列设为 NOT NULL</h3><ul><li>处理更快</li><li>查询简单，不需要监测是否 NULL</li></ul><h3 id="2-4-使用尽量“小”的数据结构"><a href="#2-4-使用尽量“小”的数据结构" class="headerlink" title="2.4 使用尽量“小”的数据结构"></a>2.4 使用尽量“小”的数据结构</h3><ul><li>数据文件变小，减少磁盘开销</li><li>索引变小</li></ul><h3 id="2-5-永远只返回需要的列"><a href="#2-5-永远只返回需要的列" class="headerlink" title="2.5 永远只返回需要的列"></a>2.5 永远只返回需要的列</h3><p>不要 <code>select \*</code> ，可以 <code>count(\*)</code>，why not:</p><ul><li>不能使用聚集索引，要查两次</li><li>增加了 IO，网络开销</li></ul><h3 id="2-6-把一个大的查询拆分成小查询"><a href="#2-6-把一个大的查询拆分成小查询" class="headerlink" title="2.6 把一个大的查询拆分成小查询"></a>2.6 把一个大的查询拆分成小查询</h3><p>虽然 MySQL 能查询百万行数据，但是大量数据发送给客户端要慢得多。</p><p>把关联查询分解，在内存中过滤也能提高效率：</p><ul><li>缓存的效率更高：缓存多事对单表进行的。</li><li>单个查询的锁竞争减小。</li><li>在应用层关联，可以对数据方便拆分。</li><li>查询本身的效率也可能更高：IN()代替关联查询，可以让 mysql 按照 ID 顺序查询，可能比随即的关联要更高效。</li><li>可以减少冗余记录的查询：在应用层关联，只针对小量数据，数据库中只需要查询一次，而关联查询是笛卡尔积，可能被关联多次。</li><li>在应用中实现了哈希关联，而不是 MySQL 的嵌套关联。</li></ul><h3 id="2-7-mysql-查询的过程"><a href="#2-7-mysql-查询的过程" class="headerlink" title="2.7 mysql 查询的过程"></a>2.7 mysql 查询的过程</h3><p>MySQL 执行一个查询的过程：</p><ol><li>客户端发送一条查询给服务器</li><li>服务器先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果，否则进入下一阶段。</li><li>服务器进行 sql 解析，预处理，再由优化器生成对应的执行计划。</li><li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li><li>讲结果返回给客户端。</li></ol><h3 id="2-8-索引优化的级别"><a href="#2-8-索引优化的级别" class="headerlink" title="2.8 索引优化的级别"></a>2.8 索引优化的级别</h3><ul><li>consts 单表中只有一行匹配（主键或唯一索引），在优化阶段即可读取数据</li><li>ref 使用普通的索引（normal index）</li><li>range 对索引范围检索</li></ul><p>优化要达到的目标 ：至少是 <code>range</code> &lt; 要求 <code>ref</code> &lt; 最好 <code>consts</code></p><h3 id="2-9-使用覆盖索引"><a href="#2-9-使用覆盖索引" class="headerlink" title="2.9 使用覆盖索引"></a>2.9 使用覆盖索引</h3><p>如果一个索引包含所有需要查询的字段的值，我们称之为“覆盖索引”。在 explain 的 extra 列可以看到“Using index”的信息。</p><h3 id="2-10-使用延迟关联或子查询优化分页"><a href="#2-10-使用延迟关联或子查询优化分页" class="headerlink" title="2.10 使用延迟关联或子查询优化分页"></a>2.10 使用延迟关联或子查询优化分页</h3><p>MySQL 查询 offset 时，先查询 offset+N，然后放弃前 offset 行，导致 offset 很大时效率低下。可以先对数据进行过滤，然后再进行关联查询。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* </span><br><span class="line"><span class="keyword">from</span> <span class="string">`table`</span> a, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="string">`table`</span> <span class="keyword">where</span> cond <span class="keyword">limit</span> <span class="number">10000</span>, <span class="number">20</span>) b </span><br><span class="line"><span class="keyword">where</span> a.id=b.id</span><br></pre></td></tr></table></figure><p>内部使用了覆盖索引，外部使用关联查询。</p><h3 id="2-11-优化关联查询"><a href="#2-11-优化关联查询" class="headerlink" title="2.11 优化关联查询"></a>2.11 优化关联查询</h3><ul><li><p>确保 on 或 using 子句的列上有索引。只需要在关联顺序中的第二个表的相应的列上创建索引。例如表 A 和表 B 用列 C 关联，如果优化器的关联顺序是 B、A，那么就不需要在 B 表的对应列上建上索引，没有用到的索引只会带来额外的负担。</p></li><li><p>确保任何的 Group BY 和 ORDER BY 中的表达式只涉及到一个表中的列，这样才能用索引优化</p><p>​</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《高性能 MySQL》</li><li>《MySQL 技术内幕》</li></ul></div><div class="post-tags"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能/">性能</a></li></ul></div></article><div class="post-nav"><div class="post-nav-item post-nav-next"><a href="/2017/12/18/2017/consistent-hashing/" rel="next" title="一致性Hash算法（Consistent Hashing）"><span>〈 </span>一致性Hash算法（Consistent Hashing）</a></div><div class="post-nav-item post-nav-prev"><a href="/2019/07/12/yinwang/learning-philosophy/" rel="prev" title="【王垠】学习的智慧">【王垠】学习的智慧 <span>〉</span></a></div></div><div id="toc" class="toc-article"><strong class="toc-title">目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-索引篇"><span class="toc-text">1. 索引篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-0-建立索引的原则"><span class="toc-text">1.0 建立索引的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-负向条件查询不能使用索引"><span class="toc-text">1.1 负向条件查询不能使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-联合索引与最左前缀"><span class="toc-text">1.2 联合索引与最左前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-查询条件中的函数或表达式不能使用索引"><span class="toc-text">1.3 查询条件中的函数或表达式不能使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-前导模糊不能使用索引"><span class="toc-text">1.4 前导模糊不能使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-使用-limit"><span class="toc-text">1.5 使用 limit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-少量的数据不应该索引"><span class="toc-text">1.6 少量的数据不应该索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-优化查询"><span class="toc-text">2. 优化查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-慢查询"><span class="toc-text">2.1 慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-避免使用自动类型转换"><span class="toc-text">2.2 避免使用自动类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-尽量把数据列设为-NOT-NULL"><span class="toc-text">2.3 尽量把数据列设为 NOT NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-使用尽量“小”的数据结构"><span class="toc-text">2.4 使用尽量“小”的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-永远只返回需要的列"><span class="toc-text">2.5 永远只返回需要的列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-把一个大的查询拆分成小查询"><span class="toc-text">2.6 把一个大的查询拆分成小查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-mysql-查询的过程"><span class="toc-text">2.7 mysql 查询的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-索引优化的级别"><span class="toc-text">2.8 索引优化的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-使用覆盖索引"><span class="toc-text">2.9 使用覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-使用延迟关联或子查询优化分页"><span class="toc-text">2.10 使用延迟关联或子查询优化分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-优化关联查询"><span class="toc-text">2.11 优化关联查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></div></div></div><footer class="footer text-center"><div id="bottom-inner"><a href="http://hexo.io" target="_blank" class="footer-link">Hexo</a> <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank" class="footer-link">Theme microb</a></div></footer><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="[闷声发大财中...] "+originTitle,clearTimeout(titleTime)):(document.title="[+1s] "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script>!function(e,t){e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(){var e=t.getElementById("menu-main-post");if(e){var n=t.getElementById("toc");e.title=n?"目录":"回到顶部",e.onclick=function(){n?"block"==n.style.display?n.style.display="none":n.style.display="block":(cancelAnimationFrame(o),o=requestAnimationFrame(function e(){var n=t.body.scrollTop||t.documentElement.scrollTop;0<n?(t.body.scrollTop=t.documentElement.scrollTop=n-50,o=requestAnimationFrame(e)):cancelAnimationFrame(o)}))}}}();var o=null}(window,document)</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b6d76ecb62c0651d8e5b7f7085f443f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-78267963-1","auto"),ga("send","pageview")</script></body></html>