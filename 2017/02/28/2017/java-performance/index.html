<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#202020"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="keywords" content="Java,性能,"><meta name="description" content="Java性能优化权威指南"><link rel="icon" type="image/x-icon" href="/logo.png"><title>Java性能优化权威指南 [ 大新闻 ]</title><link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" href="/css/microb.css"></head><body><nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed"><ul class="pure-menu-list float-r clearfix"><li class="pure-menu-item toc-menu"><a id="menu-main-post" class="pure-menu-link" href="javascript:;"><img class="menu-icon" src="/logo.png" alt="MENU"></a></li></ul><a class="pure-menu-heading" href="/"><h1 class="title">大新闻</h1></a></nav><div class="container" id="content-outer"><div class="inner" id="content-inner"><article class="post" id="post"><header class="post-header text-center"><h1 class="title">Java性能优化权威指南</h1><time class="time" datetime="2017-02-28T08:30:09.000Z">2017-02-28</time><hr></header><div class="post-content"><p>读书笔记。</p><a id="more"></a><h2 id="第3章-HotSpot-VM基本架构"><a href="#第3章-HotSpot-VM基本架构" class="headerlink" title="第3章 HotSpot VM基本架构"></a>第3章 HotSpot VM基本架构</h2><ul><li>VM垃圾回收器</li><li>JIT编译器</li><li>VM运行时</li></ul><h3 id="VM类加载："><a href="#VM类加载：" class="headerlink" title="VM类加载："></a>VM类加载：</h3><ol><li>类加载：<ul><li>根据给定的Java类或接口，根据名字找到Java类的二进制文件（二进制字节流），定义Java类，创建java.lang.Class对象;如果没有找到抛出NoClassDefFount异常。</li><li>Java类加载前，必须先加载它的所有超类或接口。</li></ul></li><li>链接：<ul><li>检查类文件的语义、常量池符号、类型；</li><li>创建静态字段初始化标准默认值（int标准值为0，而不是指定的值value=xxx），分配方法表;</li></ul></li><li>初始化:<ul><li>初始化类，运行类构造器（首先要初始化超类，不会初始化超接口）；</li></ul></li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>首个加载器成为：初始类加载器（Initiating Class Loader），最终定义类的类加载器成为：定义类加载器（Definiting Class Loader）。</p><p>层级关系顺序：启动类加载器-&gt;扩展类加载器-&gt;系统类加载器</p><h3 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h3><ul><li>新线程：线程正在初始化</li><li>线程在Java中：线程正在执行Java代码</li><li>线程在VM中：线程正在HotSpot VM中执行</li><li>线程阻塞</li><li>MONITOR_WAIT：线程正在等待获取竞争的监视锁</li><li>CONDVAR_WAIT：线程正在等待HotSpot VM使用的内部条件变量</li><li>OBJECT_WAIT：线程正在执行java.lang.Object.wait()</li></ul><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>为什么分代（弱分代假设）：</p><ul><li>大多数分配对象的存活时间很短；</li><li>存活时间久的对象很少引用存活时间短的对象；</li></ul><p>2个物理区，不算永久代（用户创建的对象不会在此，是HotSpot存放元数据的地方）：</p><ul><li><p>新生代</p><ul><li><p>Eden:新创建的对象分配在这里（不是所有的，大的对象可能直接分在老年代，因为Eden区放不下）。Minor GC后Eden去几乎总是空的。</p></li><li><p>Survivor（一对：from-to)：这里的对象至少经历了一次Minor GC，在提升到老年代之前还有一次被收集的机会。</p><p>Minor GC之后，from-to交换角色。Minor GC过程中，Survivor可能不足以容纳Eden和另一个Survivor中的存活对象，多余的对象将被移到老年代，这被成为<code>过早提升</code>（Premature Promotion）。这会导致老年代中短期存活对象的增长，可能会引发严重的性能问题。</p></li></ul></li><li><p>老年代</p><p>老年代满了（达到一定阈值）会进行Full GC.</p></li></ul><h2 id="第4章-JVM性能监控"><a href="#第4章-JVM性能监控" class="headerlink" title="第4章 JVM性能监控"></a>第4章 JVM性能监控</h2><h3 id="重要的垃圾收集数据"><a href="#重要的垃圾收集数据" class="headerlink" title="重要的垃圾收集数据"></a>重要的垃圾收集数据</h3><ul><li>当前使用的垃圾收集器</li><li>Java堆的大小</li><li>新生代和老年代的大小</li><li>永久代的大小</li><li>Minor GC的持续时间</li><li>Minor GC的频率</li><li>Minor GC的空间回收量</li><li>Full GC的持续时间</li><li>Full GC的频率</li><li>每个并发垃圾收集周期内的空间回收量</li><li>垃圾收集前后Java堆的占用量</li><li>垃圾收集前后新生代和老年代的占用量</li><li>垃圾收集前后永久代的占用量</li><li>是否老年代或永久代的占用触发了Full GC</li><li>应用是否显示调用了System.gc()</li></ul><h2 id="第6章-Java应用性能分析技巧"><a href="#第6章-Java应用性能分析技巧" class="headerlink" title="第6章 Java应用性能分析技巧"></a>第6章 Java应用性能分析技巧</h2><h3 id="性能优化机会"><a href="#性能优化机会" class="headerlink" title="性能优化机会"></a>性能优化机会</h3><ul><li>使用更高效的算法</li><li>减少锁争用</li><li>为算法生成更有效率的代码</li></ul><h1 id="第7章-性能调优"><a href="#第7章-性能调优" class="headerlink" title="第7章 性能调优"></a>第7章 性能调优</h1><h3 id="性能属性"><a href="#性能属性" class="headerlink" title="性能属性"></a>性能属性</h3><ul><li>吞吐量</li><li>延迟</li><li>内存占用</li></ul><p>这其中任何一个属性性能的提高几乎都是以另一个或者两个属性性能的损失作代价的。很多时候，某一个或两个属性的性能比另一个更重要。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>JVM垃圾收集器调优有是三个基本原则：</p><ul><li>Minor GC回收原则: 每次Minor GC都尽可能多的收集垃圾对象。可以减少应用Full GC的频率。Full GC的持续时间总是很长，是应用程序无法达到其延迟或吞吐量要求的罪魁祸首。</li><li>GC内存最大化原则：处理吞吐量和延迟问题时，垃圾处理器能使用的内存越大，即Java堆空间越大，垃圾收集的效果越好，应用程序运行也越流畅。</li><li>GC调优的3选2原则：在这三个属性中任意选择两个进行JVM垃圾收集器调优。</li></ul></div><div class="post-tags"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能/">性能</a></li></ul></div></article><div class="post-nav"><div class="post-nav-item post-nav-next"><a href="/2017/01/10/2017/node-sass-called-fsevents-install-error/" rel="next" title="解决node-sass-called-fsevents-install-error"><span>〈 </span>解决node-sass-called-fsevents-install-error</a></div><div class="post-nav-item post-nav-prev"><a href="/2017/03/17/2017/node-run-pm2-in-production-env/" rel="prev" title="在生产环境中使用PM2运行Node">在生产环境中使用PM2运行Node <span>〉</span></a></div></div><div id="toc" class="toc-article"><strong class="toc-title">目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第3章-HotSpot-VM基本架构"><span class="toc-text">第3章 HotSpot VM基本架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VM类加载："><span class="toc-text">VM类加载：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器"><span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程状态："><span class="toc-text">线程状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器"><span class="toc-text">垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第4章-JVM性能监控"><span class="toc-text">第4章 JVM性能监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重要的垃圾收集数据"><span class="toc-text">重要的垃圾收集数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第6章-Java应用性能分析技巧"><span class="toc-text">第6章 Java应用性能分析技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化机会"><span class="toc-text">性能优化机会</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#第7章-性能调优"><span class="toc-text">第7章 性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#性能属性"><span class="toc-text">性能属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原则"><span class="toc-text">原则</span></a></li></ol></li></div></div></div><footer class="footer text-center"><div id="bottom-inner"><a href="http://hexo.io" target="_blank" class="footer-link">Hexo</a> <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank" class="footer-link">Theme microb</a></div></footer><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="[闷声发大财中...] "+originTitle,clearTimeout(titleTime)):(document.title="[+1s] "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script>!function(e,n){function t(){cancelAnimationFrame(o),o=requestAnimationFrame(function e(){var t=n.body.scrollTop||n.documentElement.scrollTop;t>0?(n.body.scrollTop=n.documentElement.scrollTop=t-50,o=requestAnimationFrame(e)):cancelAnimationFrame(o)})}e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(){var e=n.getElementById("menu-main-post");if(e){var o=n.getElementById("toc");e.title=o?"目录":"回到顶部",e.onclick=function(){o?"block"==o.style.display?o.style.display="none":o.style.display="block":t()}}}();var o=null}(window,document)</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b6d76ecb62c0651d8e5b7f7085f443f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-78267963-1","auto"),ga("send","pageview")</script></body></html>