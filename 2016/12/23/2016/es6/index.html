<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#202020"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="keywords" content="手册,es6,"><meta name="description" content="ES6/ES7参考手册"><link rel="icon" type="image/x-icon" href="/logo.png"><title>ES6/ES7参考手册 [ 大新闻 ]</title><link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" href="/css/microb.css"></head><body><nav class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed"><ul class="pure-menu-list float-r clearfix"><li class="pure-menu-item toc-menu"><a id="menu-main-post" class="pure-menu-link" href="javascript:;"><img class="menu-icon" src="/logo.png" alt="MENU"></a></li></ul><a class="pure-menu-heading" href="/"><h1 class="title">大新闻</h1></a></nav><div class="container" id="content-outer"><div class="inner" id="content-inner"><article class="post" id="post"><header class="post-header text-center"><h1 class="title">ES6/ES7参考手册</h1><time class="time" datetime="2016-12-23T08:08:28.000Z">2016-12-23</time><hr></header><div class="post-content"><p>本文档记录学习ECMAScript 6过程中的各个方面内容，包含了一些ES6/7的新语法和一些编码建议，较零散，作参考。</p><a id="more"></a><ul><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6入门</a></li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">Javascript秘密花园</a></li><li><a href="https://github.com/yuche/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style</a></li></ul><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1.对象"></a>1.对象</h2><h3 id="1-1-使用字面量创建对象"><a href="#1-1-使用字面量创建对象" class="headerlink" title="1.1 使用字面量创建对象"></a>1.1 使用字面量创建对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> item = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-对象属性简写"><a href="#1-2-对象属性简写" class="headerlink" title="1.2 对象属性简写"></a>1.2 对象属性简写</h3><blockquote><p>ES6推荐使用对象属性简写，支持对象的属性和方法。</p><p>为什么？因为这样更短更有描述性。</p></blockquote><ul><li>下面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法也可以简写：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad 原始写法</span></span><br><span class="line"><span class="keyword">const</span> atom = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  addValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> atom.value + value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good 简写</span></span><br><span class="line"><span class="keyword">const</span> atom = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  addValue(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> atom.value + value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>用于返回值时使用简写，特别简洁：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;; <span class="comment">// 这里是简写返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>在对象属性声明前把简写的属性分组</strong></li></ul><blockquote><p>为什么？因为这样能清楚地看出哪些属性使用了简写。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> anakinSkywalker = <span class="string">'Anakin Skywalker'</span>;</span><br><span class="line"> <span class="keyword">const</span> lukeSkywalker = <span class="string">'Luke Skywalker'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// bad</span></span><br><span class="line"> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">   episodeOne: <span class="number">1</span>,</span><br><span class="line">   twoJedisWalkIntoACantina: <span class="number">2</span>,</span><br><span class="line">   lukeSkywalker,</span><br><span class="line">   episodeThree: <span class="number">3</span>,</span><br><span class="line">   mayTheFourth: <span class="number">4</span>,</span><br><span class="line">   anakinSkywalker,</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// good</span></span><br><span class="line"> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">   lukeSkywalker,</span><br><span class="line">   anakinSkywalker,</span><br><span class="line">   episodeOne: <span class="number">1</span>,</span><br><span class="line">   twoJedisWalkIntoACantina: <span class="number">2</span>,</span><br><span class="line">   episodeThree: <span class="number">3</span>,</span><br><span class="line">   mayTheFourth: <span class="number">4</span>,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="2-1-使用字面量创建数组"><a href="#2-1-使用字面量创建数组" class="headerlink" title="2.1 使用字面量创建数组"></a>2.1 使用字面量创建数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> items = [];</span><br></pre></td></tr></table></figure><h3 id="2-2-使用push代替直接赋值"><a href="#2-2-使用push代替直接赋值" class="headerlink" title="2.2 使用push代替直接赋值"></a>2.2 使用push代替直接赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someStack = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">someStack[someStack.length] = <span class="string">'abracadabra'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">someStack.push(<span class="string">'abracadabra'</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3-使用使用拓展运算符-复制数组。"><a href="#2-3-使用使用拓展运算符-复制数组。" class="headerlink" title="2.3 使用使用拓展运算符 ... 复制数组。"></a>2.3 使用使用拓展运算符 <code>...</code> 复制数组。</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> len = items.length;</span><br><span class="line"><span class="keyword">const</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> itemsCopy = [...items];</span><br></pre></td></tr></table></figure><p>###　2.4 使用 Array#from 把一个类数组对象转换成数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo);</span><br></pre></td></tr></table></figure><h3 id="2-5-对象解构赋值"><a href="#2-5-对象解构赋值" class="headerlink" title="2.5 对象解构赋值"></a>2.5 对象解构赋值</h3><ul><li>数组可以</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构的默认值</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">null</span>]; <span class="comment">// x='a', y=null</span></span><br></pre></td></tr></table></figure><ul><li>对象可以</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果变量名不一致，需要指定别名</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// 'hello'</span></span><br><span class="line">l <span class="comment">// 'world'</span></span><br><span class="line">first <span class="comment">// error: foo is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构的默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</p></blockquote><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。如果解构不成功，变量的值就等于<code>undefined</code>。</p><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><h3 id="3-1-使用单引号-39-39"><a href="#3-1-使用单引号-39-39" class="headerlink" title="3.1 使用单引号&#39;&#39;"></a>3.1 使用单引号<code>&#39;&#39;</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob Parr"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob Parr'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">"Bob "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">'Bob '</span> + <span class="keyword">this</span>.lastName;</span><br></pre></td></tr></table></figure><h3 id="3-2-使用模板连接字符串"><a href="#3-2-使用模板连接字符串" class="headerlink" title="3.2 使用模板连接字符串"></a>3.2 使用模板连接字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`<span class="subst">$&#123;name&#125;</span> is a man`</span> <span class="comment">// good 字符串模板优先</span></span><br><span class="line">[<span class="string">'How are you, '</span>, name, <span class="string">'?'</span>].join() <span class="comment">// bad 其次是join</span></span><br><span class="line"><span class="string">'How are you, '</span> + name + <span class="string">'?'</span> <span class="comment">// bad 最后才是连接符</span></span><br></pre></td></tr></table></figure><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h2><h3 id="4-1-函数声明优先"><a href="#4-1-函数声明优先" class="headerlink" title="4.1 函数声明优先"></a>4.1 函数声明优先</h3><blockquote><p>为什么？因为函数声明是可命名的，所以他们在调用栈中更容易被识别。此外，函数声明会把整个函数提升（hoisted），而函数表达式只会把函数的引用变量名提升。这条规则使得<a href="https://github.com/yuche/javascript#arrow-functions" target="_blank" rel="noopener">箭头函数</a>可以取代函数表达式。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-函数参数"><a href="#4-2-函数参数" class="headerlink" title="4.2 函数参数"></a>4.2 函数参数</h3><p>直接给函数的参数指定默认值，不要使用一个变化的函数参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// really bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不！我们不应该改变函数参数。</span></span><br><span class="line">  <span class="comment">// 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。</span></span><br><span class="line">  <span class="comment">// 但这样的写法会造成一些 Bugs。</span></span><br><span class="line">  <span class="comment">//（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。）</span></span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// still bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opts === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推荐，如果有多个参数，请使用参数对象包装，这样在增加参数的时候，不需要改变函数声明。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">$(<span class="keyword">this</span>).trigger(<span class="string">'listingUpdated'</span>, listing.id);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$(<span class="keyword">this</span>).on(<span class="string">'listingUpdated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, listingId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with listingId</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">$(<span class="keyword">this</span>).trigger(<span class="string">'listingUpdated'</span>, &#123; <span class="attr">listingId</span> : listing.id &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">$(<span class="keyword">this</span>).on(<span class="string">'listingUpdated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with data.listingId</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-3-箭头函数"><a href="#4-3-箭头函数" class="headerlink" title="4.3 箭头函数"></a>4.3 箭头函数</h3><ul><li>当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。</li></ul><blockquote><p>为什么?因为箭头函数创造了新的一个 <code>this</code> 执行环境（译注：参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">Arrow functions - JavaScript | MDN</a> 和 <a href="http://toddmotto.com/es6-arrow-functions-syntaxes-and-lexical-scoping/" target="_blank" rel="noopener">ES6 arrow functions, syntax and lexical scoping</a>），通常情况下都能满足你的需求，而且这样的写法更为简洁。</p><p>为什么不？如果你有一个相当复杂的函数，你或许可以把逻辑部分转移到一个函数声明上。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 <code>return</code> 都省略掉。如果不是，那就不要省略。</li></ul><blockquote><p>为什么？语法糖。在链式调用中可读性很高。</p><p>为什么不？当你打算回传一个对象的时候。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function">(<span class="params">total, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + n;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="4-4-函数参数默认值"><a href="#4-4-函数参数默认值" class="headerlink" title="4.4 函数参数默认值"></a>4.4 函数参数默认值</h3><p>在4.2中知道，函数的参数现在允许使用默认值了，写法就是<code>(a = value)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，参数的默认值顺序，最好写在末尾参数，即使非末尾参数指定了默认值，在使用时也不能省略该参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined])</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]/// 注意这里，和null的区别</span></span><br><span class="line">f(<span class="literal">null</span>, <span class="number">1</span>) <span class="comment">// [null, 1] /// 注意这里，和undefined的区别</span></span><br></pre></td></tr></table></figure><p>如果非尾参数指定了默认值，除非显示的传入<code>undefined</code>，否则将无法触发参数的默认值。<code>null</code> 值则仍未null值。</p><blockquote><p>注意，如果给参数指定了默认值，函数的length属性则为预期需要传入的参数个数，如果非尾参数，则会忽略计算后面的参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a=<span class="number">1</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b=<span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c=<span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="4-5-函数参数的解构赋值"><a href="#4-5-函数参数的解构赋值" class="headerlink" title="4.5 函数参数的解构赋值"></a>4.5 函数参数的解构赋值</h3><p>在之前的章节中，介绍了对象的解构赋值，同样，函数的参数（包括构造函数）也可以解构。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined, 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1, 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1, 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure><p>利用这个特性，我们可以写出非常简洁的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是通用返回结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; data, code = <span class="number">200</span>, message = <span class="string">'执行成功'</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    <span class="keyword">if</span>(!!data) &#123; <span class="comment">// null值将被忽略</span></span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> ok(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(&#123; data &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> error(code, message) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result( &#123; code, message &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// success时返回</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;<span class="attr">user</span>: <span class="string">'abc'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> result = Result.ok(data);</span><br><span class="line">ctx.body = result; </span><br><span class="line"></span><br><span class="line"><span class="comment">// error时返回</span></span><br><span class="line"><span class="keyword">const</span> result = Result.error(<span class="number">401</span>, <span class="string">'Unauthorized'</span>);</span><br><span class="line">ctx.body = result;</span><br></pre></td></tr></table></figure><h2 id="5-模块"><a href="#5-模块" class="headerlink" title="5.模块"></a>5.模块</h2><h3 id="5-1-总是使用import-export"><a href="#5-1-总是使用import-export" class="headerlink" title="5.1 总是使用import/export"></a>5.1 总是使用<code>import/export</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure><h3 id="5-2-不要使用import通配符"><a href="#5-2-不要使用import通配符" class="headerlink" title="5.2 不要使用import通配符"></a>5.2 不要使用import通配符</h3><blockquote><p>Why? This makes sure you have a single default export.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span>;</span><br></pre></td></tr></table></figure><h3 id="5-3-不要导出可变的对象"><a href="#5-3-不要导出可变的对象" class="headerlink" title="5.3 不要导出可变的对象"></a>5.3 不要导出可变的对象</h3><blockquote><p>Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported.</p><p>eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-mutable-exports.md" target="_blank" rel="noopener"><code>import/no-mutable-exports</code></a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">export</span> &#123; foo &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// good</span></span><br><span class="line">  <span class="keyword">const</span> foo = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">export</span> &#123; foo &#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-如果只有一个导出，使用default"><a href="#5-4-如果只有一个导出，使用default" class="headerlink" title="5.4 如果只有一个导出，使用default."></a>5.4 如果只有一个导出，使用default.</h3><blockquote><p>eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/prefer-default-export.md" target="_blank" rel="noopener"><code>import/prefer-default-export</code></a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="6-并发"><a href="#6-并发" class="headerlink" title="6.并发"></a>6.并发</h2><h3 id="6-1-async-and-await"><a href="#6-1-async-and-await" class="headerlink" title="6.1 async and await"></a>6.1 async and await</h3><p>下面的代码是koa2中的router filter，我们利用async和await，以及Promise，同时执行了两个数据库查询，等待执行完毕后，返回结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User.findById 和Channel.findOne将被同时触发</span></span><br><span class="line"><span class="keyword">async</span> me(ctx, next) &#123;</span><br><span class="line">    <span class="keyword">const</span> _me = ctx.state.user; </span><br><span class="line">    <span class="keyword">const</span>[user, channel] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([User.findById(_me.id), Channel.findOne()]);</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      user,</span><br><span class="line">      channel,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><hr><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>使用eslint: eslint-config-airbnb-base</p><h3 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h3><ul><li><p>行首逗号：<strong>不需要</strong>。eslint: <a href="http://eslint.org/docs/rules/comma-style.html" target="_blank" rel="noopener"><code>comma-style</code></a> jscs: <a href="http://jscs.info/rule/requireCommaBeforeLineBreak" target="_blank" rel="noopener"><code>requireCommaBeforeLineBreak</code></a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> story = [</span><br><span class="line">    once</span><br><span class="line">  , upon</span><br><span class="line">  , aTime</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> story = [</span><br><span class="line">  once,</span><br><span class="line">  upon,</span><br><span class="line">  aTime,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> hero = &#123;</span><br><span class="line">    firstName: <span class="string">'Ada'</span></span><br><span class="line">  , <span class="attr">lastName</span>: <span class="string">'Lovelace'</span></span><br><span class="line">  , <span class="attr">birthYear</span>: <span class="number">1815</span></span><br><span class="line">  , <span class="attr">superPower</span>: <span class="string">'computers'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Ada'</span>,</span><br><span class="line">  lastName: <span class="string">'Lovelace'</span>,</span><br><span class="line">  birthYear: <span class="number">1815</span>,</span><br><span class="line">  superPower: <span class="string">'computers'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>增加结尾的逗号: <strong>需要</strong>。</p><blockquote><p>为什么? 这会让 git diffs 更干净。另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的<a href="https://github.com/yuche/javascript/blob/master/es5/README.md#commas" target="_blank" rel="noopener">尾逗号问题</a>。</p><p>eslint: <a href="http://eslint.org/docs/rules/comma-dangle.html" target="_blank" rel="noopener"><code>comma-dangle</code></a> jscs: <a href="http://jscs.info/rule/requireTrailingComma" target="_blank" rel="noopener"><code>requireTrailingComma</code></a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad - git diff without trailing comma</span></span><br><span class="line"><span class="keyword">const</span> hero = &#123;</span><br><span class="line">     firstName: <span class="string">'Florence'</span>,</span><br><span class="line">-    lastName: <span class="string">'Nightingale'</span></span><br><span class="line">+    lastName: <span class="string">'Nightingale'</span>,</span><br><span class="line">+    inventorOf: [<span class="string">'coxcomb chart'</span>, <span class="string">'modern nursing'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good - git diff with trailing comma</span></span><br><span class="line"><span class="keyword">const</span> hero = &#123;</span><br><span class="line">     firstName: <span class="string">'Florence'</span>,</span><br><span class="line">     lastName: <span class="string">'Nightingale'</span>,</span><br><span class="line">+    inventorOf: [<span class="string">'coxcomb chart'</span>, <span class="string">'modern nursing'</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p><strong>使用分号</strong></p><blockquote><p>eslint: <a href="http://eslint.org/docs/rules/semi.html" target="_blank" rel="noopener"><code>semi</code></a> jscs: <a href="http://jscs.info/rule/requireSemicolons" target="_blank" rel="noopener"><code>requireSemicolons</code></a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span></span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good (防止函数在两个 IIFE 合并时被当成一个参数)</span></span><br><span class="line">;<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>示例：.babelrc</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"flow-vue"</span>],</span><br><span class="line">  <span class="attr">"ignore"</span>: [</span><br><span class="line">    <span class="string">"dist/*.js"</span>,</span><br><span class="line">    <span class="string">"packages/**/*.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>presets</code>字段设定转码规则，官方提供以下的规则集<a href="http://babeljs.cn/docs/plugins/#presets" target="_blank" rel="noopener">presets</a></p><p>关于ES7不同阶段的提案， stage-0 &gt; stage-1 &gt; stage-2 &gt; stage-3</p></blockquote><p>参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="noopener">Babel 入门教程</a></li><li><a href="https://github.com/hehongwei44/babel-hankbook" target="_blank" rel="noopener">babel-hankbook</a></li></ul></div><div class="post-tags"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/手册/">手册</a></li></ul></div></article><div class="post-nav"><div class="post-nav-item post-nav-next"><a href="/2016/12/20/2016/css-keyframes-animation/" rel="next" title="css-keyframes-animation"><span>〈 </span>css-keyframes-animation</a></div><div class="post-nav-item post-nav-prev"><a href="/2016/12/27/2016/Restful-Patch-Idempotent/" rel="prev" title="Restful从入门到放弃-关于Patch不是幂等的想到的">Restful从入门到放弃-关于Patch不是幂等的想到的 <span>〉</span></a></div></div><div id="toc" class="toc-article"><strong class="toc-title">目录</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-对象"><span class="toc-text">1.对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-使用字面量创建对象"><span class="toc-text">1.1 使用字面量创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-对象属性简写"><span class="toc-text">1.2 对象属性简写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数组"><span class="toc-text">2.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-使用字面量创建数组"><span class="toc-text">2.1 使用字面量创建数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-使用push代替直接赋值"><span class="toc-text">2.2 使用push代替直接赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-使用使用拓展运算符-复制数组。"><span class="toc-text">2.3 使用使用拓展运算符 ... 复制数组。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-对象解构赋值"><span class="toc-text">2.5 对象解构赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-字符串"><span class="toc-text">3.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-使用单引号-39-39"><span class="toc-text">3.1 使用单引号&#39;&#39;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-使用模板连接字符串"><span class="toc-text">3.2 使用模板连接字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-函数"><span class="toc-text">4.函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-函数声明优先"><span class="toc-text">4.1 函数声明优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-函数参数"><span class="toc-text">4.2 函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-箭头函数"><span class="toc-text">4.3 箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-函数参数默认值"><span class="toc-text">4.4 函数参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-函数参数的解构赋值"><span class="toc-text">4.5 函数参数的解构赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-模块"><span class="toc-text">5.模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-总是使用import-export"><span class="toc-text">5.1 总是使用import/export</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-不要使用import通配符"><span class="toc-text">5.2 不要使用import通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-不要导出可变的对象"><span class="toc-text">5.3 不要导出可变的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-如果只有一个导出，使用default"><span class="toc-text">5.4 如果只有一个导出，使用default.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-并发"><span class="toc-text">6.并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-async-and-await"><span class="toc-text">6.1 async and await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码风格"><span class="toc-text">代码风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#逗号"><span class="toc-text">逗号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分号"><span class="toc-text">分号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Babel"><span class="toc-text">Babel</span></a></li></ol></li></ol></div></div></div><footer class="footer text-center"><div id="bottom-inner"><a href="http://hexo.io" target="_blank" class="footer-link">Hexo</a> <a href="https://github.com/microacup/hexo-theme-micorb" target="_blank" class="footer-link">Theme microb</a></div></footer><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="[闷声发大财中...] "+originTitle,clearTimeout(titleTime)):(document.title="[+1s] "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script>!function(e,t){e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(){var e=t.getElementById("menu-main-post");if(e){var n=t.getElementById("toc");e.title=n?"目录":"回到顶部",e.onclick=function(){n?"block"==n.style.display?n.style.display="none":n.style.display="block":(cancelAnimationFrame(o),o=requestAnimationFrame(function e(){var n=t.body.scrollTop||t.documentElement.scrollTop;0<n?(t.body.scrollTop=t.documentElement.scrollTop=n-50,o=requestAnimationFrame(e)):cancelAnimationFrame(o)}))}}}();var o=null}(window,document)</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b6d76ecb62c0651d8e5b7f7085f443f1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-78267963-1","auto"),ga("send","pageview")</script></body></html>